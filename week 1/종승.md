# 1. 스코프에 대해서 설명해주세요

<br>

## 😜 스코프란?

스코프는 변수나 함수의 이름처럼, 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름을 찾아내기 위한 `규칙`입니다. 이 유일한 이름을 `식별자`라고도 합니다.

프로그래밍은 변수를 선언하고 값을 할당하며 변수를 참조하는 기본적인 기능을 제공하며, 이 기능으로 프로그램의 상태를 관리할 수 있습니다. 변수는 전역, 코드 블록, 함수 내에서 선언하며 식별자는 자신이 어디에서 선언됐는지에 의해 유효한 특정 범위를 갖습니다.

만약 스코프가 없다면 같은 식별자 이름은 충돌을 일으킬 것이므로 프로그램 전체에서 유일한 이름은 단 하나밖에 사용할 수 없을 것입니다. 스코프는 이와 같은 식별자 이름의 충돌을 방지합니다.

<br>

## 😜 꼬리 질문 대비

<br>

### 스코프의 구분

- 전역 스코프: 코드 어디에서든 참조할 수 있다.
- 지역 스코프: 함수 코드 블록이 만든 스코프로, 함수 자신과 하위 함수에서만 참조할 수 있다.

### 함수 스코프와 블록 스코프

var 키워드는 함수 스코프를 가진다.
let, const 키워드는 블록 스코프를 가진다.

<br>

## 😜 추가로 찾아볼 개념

### 렉시컬(스태틱) 스코프, 다이나믹 스코프

### 클로저

<br>

# 2. 배열, 객체를 `const`로 선언했을 때 요소나 속성을 추가할 수 있는 이유는 무엇인가?

<br>

## 😜 배열, 객체를 `const`로 선언했을 때 요소나 속성을 추가할 수 있는 이유는 무엇인가?

JavaScript 배열은 객체입니다. 객체의 경우 `const`로 선언해도 객체가 저장된 공간의 주소만 변하지 않는 상수일 뿐, 객체 안의 내용은 변경 가능합니다.

<br>

## 😜 꼬리 질문 대비

<br>

### 왜 배열은 객체죠?

JavaScript의 배열은 그 요소가 연속적으로 이어져 있지 않은 `희소 배열`입니다. 즉, 일반적인 배열이 아니라 인덱스를 프로퍼티로 가지며 `length` 프로퍼티를 갖는 특수한 객체입니다. JavaScript에서 배열의 요소란, 사실 프로퍼티에 해당하는 값입니다. JavaScript에서 사용할 수 있는 모든 값은 객체의 프로퍼티 값이 될 수 있으므로 어떤 타입이라도 배열의 요소가 될 수 있습니다.

<br>

### 일반적인 배열이란?

일반적으로 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말합니다. 즉, 배열의 요소는 하나의 타입으로 통일되어 있으며 서로 연속적으로 인접해 있습니다. 이러한 배열을 밀집 배열이라고 합니다.

<br>

### 일반적인 배열과 자바스크립트 배열의 장단점?

일반적인 배열은 인덱스로 빠르게 배열 요소에 접근할 수 있습니다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에 있어서는 효율적이지 않습니다.

자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우 일반적인 배열보다 그 속도가 느릴 수 밖에 없습니다. 하지만 특정 요소를 탐색하거나 요소를 삽입, 삭제하는 경우에는 일반적인 배열보다 빠릅니다. 

이처럼 인덱스로 배열 요소에 접근할 때 일반적인 배열보다 느릴 수 밖에 없는 단점을 보완하기 위해, 대부분의 모던 자바스크립트 엔진은 배열을 일반 객체와 구별하여 보다 배열처럼 동작할 수 있게끔 구현되어 있다.

<br>

# 3. 원시 자료형과 참조 자료형에 대해 설명해주세요.

<br>

## 😜 원시 자료형과 참조 자료형

<br>
원시 자료형은 객체가 아니면서 메서드를 가지지 않는 6가지의 타입입니다. <br>
string, number, bigint, boolean, undefined, symbol, (null)<br>
원시 자료형의 보관함인 변수에는 하나의 데이터만 담을 수 있습니다.<br>
<br>
참조 자료형은 원시 자료형이 아닌 모든 데이터를 의미합니다. 배열, 객체, 함수가 대표적인 참조 자료형 데이터입니다.<br>
참조 자료형을 변수에 할당할 때는 변수에 값이 아닌 주소를 저장합니다.

<br>

# 4. 얕은 복사와 깊은 복사에 대해 설명해주세요.

<br>

## 😜 얕은 복사와 깊은 복사?

얕은 복사란, 참조형 타입의 값에서 바로 아래 단계의 값만 복사하는 방식입니다.
깊은 복사란, 참조형 타입 안의 모든 참조가 끊어지는 방식입니다.

<br>

## 😜 꼬리 질문 대비

<br>

### 원시 자료형의 깊은 복사

원시 자료형으로 선언된 변수를 새로운 변수에 할당했을 경우, 해당 변수는 값 뿐만 아니라 기존 변수의 주소까지 복사합니다. 그래서 동등 연산자로 비교할 경우 두 개의 변수는 완전히 일치하게 됩니다.

<br>

### 참조 자료형의 깊은 복사

참조 자료형으로 선언된 변수(예를 들어 객체)를 새로운 변수에 할당했을 경우, 해당 변수는 값 뿐만 아니라 기존 변수의 주소까지 복사합니다. 그래서 동등 연산자로 비교할 경우 두 개의 변수는 완전히 일치하게 됩니다.

깊은 복사가 되었기 때문에 첫 객체의 프로퍼티 값에 변화를 줄 경우, 두번째 객체의 프로퍼티 값도 함께 변하게 됩니다.

<br>

### 참조 자료형의 얕은 복사

얕은 복사란 앞서 말했 듯 참조형 타입의 데이터 바로 아래 단계 값만 복사하는 방식입니다. 하나의 예로 스프레드 연산자를 사용하는 방식이 있습니다. 스프레드 연산자로 객체를 복사해 새로운 변수에 할당했을 경우, 두 객체는 서로 다른 주소를 가지고 있지만 객체 안의 프로퍼티는 동일한 주소를 가지게 됩니다.

<br>

### React에서 DOM을 새로 그리는 기준?

얕은 비교입니다.

리액트에서 DOM을 변경시키는 방법은 props와 상태 값을 변경하는 것입니다. 상태 값이 변경되면 리액트는 새 데이터로 DOM을 다시 그립니다.

객체를 상태로 정의한 후, 객체 내의 프로퍼티에 직접 변화를 주고 해당 객체를 setState로 갱신시켰을 경우 DOM은 다시 그려지지 않습니다. 그 이유는 리액트에서 상태값을 비교할 때 `얕은 비교`를 사용하기 때문입니다. 프로퍼티가 변한 객체는 새로 만들어진 주소값을 가지지 않기 때문에 리액트는 두 객체를 동일한 객체로 인지하고 DOM을 업데이트하지 않습니다.
