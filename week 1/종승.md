---
layout: post
title: cs 스터디 week 1 정리 및 개념 보충
date: 2023-06-29 04:00:00 +0900
category: Interview
published: true
---

# 1. 스코프에 대해서 설명해주세요

## 😜 스코프란?

스코프는 변수나 함수의 이름처럼, 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름을 찾아내기 위한 `규칙`입니다. 이 유일한 이름을 `식별자`라고도 합니다.

프로그래밍은 변수를 선언하고 값을 할당하며 변수를 참조하는 기본적인 기능을 제공하며, 이 기능으로 프로그램의 상태를 관리할 수 있습니다. 변수는 전역, 코드 블록, 함수 내에서 선언하며 식별자는 자신이 어디에서 선언됐는지에 의해 유효한 특정 범위를 갖습니다.

만약 스코프가 없다면 같은 식별자 이름은 충돌을 일으킬 것이므로 프로그램 전체에서 유일한 이름은 단 하나밖에 사용할 수 없을 것입니다. 스코프는 이와 같은 식별자 이름의 충돌을 방지합니다.

<br>

## 😜 꼬리 질문 대비

<br>

### 스코프의 구분

- 전역 스코프: 코드 어디에서든 참조할 수 있다.
- 지역 스코프: 함수 코드 블록이 만든 스코프로, 함수 자신과 하위 함수에서만 참조할 수 있다.

### let과 const의 등장 배경

- var 키워드는 함수 스코프를 가진다. 따라서 함수 외부에서 선언한 변수는 모두 전역 변수다. 이는 전역 변수를 남발할 가능성을 높인다.
- var 키워드는 생략이 허용된다. 이는 암묵적 전역 변수를 양산할 가능성을 증가시킨다.
- var 키워드로 선언한 변수는 중복 선언이 허용된다. 이로 인해 의도치 않은 변수값의 변경이 일어날 가능성이 크다.
- var 키워드로 선언한 변수에는 호이스팅이 발생해서, 해당 변수를 선언하기 이전에도 그 변수를 참조할 수 있다.

대부분의 문제는 전역 변수로 인해 발생한다. 전역 변수는 어디에서 어떻게 사용될 것인지 파악하기 힘들며, 비순수 함수에 의해 의도치 않게 변경될 수도 있어서 복잡성을 증가시킨다. 따라서 변수의 스코프는 좁을 수록 좋다. 

ES6는 이러한 `var` 키워드의 단점을 보완하기 위해 `let`과 `const` 키워드를 도입했다.

`let`, `const` 키워드는 블록 스코프를 가진다.

#### 함수 레벨 스코프

- 함수의 코드 블록만을 스코프로 인정한다. 
- ex) `for` 문의 변수 선언문에서 var로 선언한 변수를 for 문의 코드 블록 외부에서 참조할 수 있다.

#### 블록 레벨 스코프

- 모든 코드 블록(함수, `if`문, `for`문, `while`문, `try`/`catch`문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수다.

<br>

## 😜 추가로 찾아볼 개념

### 렉시컬(스태틱) 스코프, 다이나믹 스코프

렉시컬 스코프란 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정하는 것입니다.

다이나믹 스코프란 함수를 어디서 호출하였는지에 따라 상위 스코프를 결정하는 것입니다.

자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프입니다.

### 클로저

클로저는 함수와, 그 함수가 접근할 수 있는 변수의 조합입니다.

클로저는 데이터 보존, 커링 등에 사용됩니다.

클로저는 `class` 키워드가 없던 시절 모듈 패턴을 구현하기 위해 사용됐던 만큼, 특정 데이터를 다른 코드의 실행으로부터 보호해야 할 때 용이합니다.

<br>

# 2. 배열, 객체를 `const`로 선언했을 때 요소나 속성을 추가할 수 있는 이유는 무엇인가?

<br>

## 😜 배열, 객체를 `const`로 선언했을 때 요소나 속성을 추가할 수 있는 이유는 무엇인가?

JavaScript 배열은 객체입니다. 객체의 경우 `const`로 선언해도 객체가 저장된 공간의 주소만 변하지 않는 상수일 뿐, 객체 안의 내용은 변경 가능합니다.

<br>

## 😜 꼬리 질문 대비

<br>

### 왜 배열은 객체죠?

JavaScript의 배열은 그 요소가 연속적으로 이어져 있지 않은 `희소 배열`입니다. 즉, 일반적인 배열이 아니라 인덱스를 프로퍼티로 가지며 `length` 프로퍼티를 갖는 특수한 객체입니다. JavaScript에서 배열의 요소란, 사실 프로퍼티에 해당하는 값입니다. JavaScript에서 사용할 수 있는 모든 값은 객체의 프로퍼티 값이 될 수 있으므로 어떤 타입이라도 배열의 요소가 될 수 있습니다.

<br>

### 일반적인 배열이란?

일반적으로 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말합니다. 즉, 배열의 요소는 하나의 타입으로 통일되어 있으며 서로 연속적으로 인접해 있습니다. 이러한 배열을 밀집 배열이라고 합니다.

<br>

### 일반적인 배열과 자바스크립트 배열의 장단점?

일반적인 배열은 인덱스로 빠르게 배열 요소에 접근할 수 있습니다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에 있어서는 효율적이지 않습니다.

자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우 일반적인 배열보다 그 속도가 느릴 수 밖에 없습니다. 하지만 특정 요소를 탐색하거나 요소를 삽입, 삭제하는 경우에는 일반적인 배열보다 빠릅니다. 

이처럼 인덱스로 배열 요소에 접근할 때 일반적인 배열보다 느릴 수 밖에 없는 단점을 보완하기 위해, 대부분의 모던 자바스크립트 엔진은 배열을 일반 객체와 구별하여 보다 배열처럼 동작할 수 있게끔 구현되어 있다.

<br>

# 3. 원시 자료형과 참조 자료형에 대해 설명해주세요.

<br>

## 😜 원시 자료형과 참조 자료형

<br>
원시 자료형은 객체가 아니면서 메서드를 가지지 않는 6가지의 타입입니다. <br>
string, number, bigint, boolean, undefined, symbol, (null)<br>
원시 자료형의 보관함인 변수에는 하나의 데이터만 담을 수 있습니다.<br>
<br>
참조 자료형은 원시 자료형이 아닌 모든 데이터를 의미합니다. 배열, 객체, 함수가 대표적인 참조 자료형 데이터입니다.<br>
참조 자료형을 변수에 할당할 때는 변수에 값이 아닌 주소를 저장합니다.

<br>

# 4. 얕은 복사와 깊은 복사에 대해 설명해주세요.

<br>

## 😜 얕은 복사와 깊은 복사?

얕은 복사란, 참조형 타입의 데이터가 저장한 메모리 주소 값을 복사한 것을 의미합니다.
깊은 복사란, 새로운 메모리 공간을 확보해 완전히 복사하는 것을 의미합니다.

<br>

## 😜 꼬리 질문 대비

<br>

### 원시 자료형의 깊은 복사

원시 자료형으로 선언된 변수를 새로운 변수에 할당했을 경우, 해당 변수는 값 뿐만 아니라 기존 변수의 주소까지 복사합니다. 그래서 동등 연산자로 비교할 경우 두 개의 변수는 완전히 일치하게 됩니다.

<br>

### 참조 자료형의 깊은 복사

참조 자료형으로 선언된 변수(예를 들어 객체)를 새로운 변수에 할당했을 경우, 해당 변수는 값 뿐만 아니라 기존 변수의 주소까지 복사합니다. 그래서 동등 연산자로 비교할 경우 두 개의 변수는 완전히 일치하게 됩니다.

깊은 복사가 되었기 때문에 첫 객체의 프로퍼티 값에 변화를 줄 경우, 두번째 객체의 프로퍼티 값도 함께 변하게 됩니다.

<br>

### 참조 자료형의 얕은 복사

얕은 복사란 앞서 말했 듯 참조형 타입의 데이터 바로 아래 단계 값만 복사하는 방식입니다. 하나의 예로 스프레드 연산자를 사용하는 방식이 있습니다. 스프레드 연산자로 객체를 복사해 새로운 변수에 할당했을 경우, 두 객체는 서로 다른 주소를 가지고 있지만 객체 안의 프로퍼티는 동일한 주소를 가지게 됩니다.

<br>

### React에서 DOM을 새로 그리는 기준?

얕은 비교입니다.

리액트에서 DOM을 변경시키는 방법은 props와 상태 값을 변경하는 것입니다. 상태 값이 변경되면 리액트는 새 데이터로 DOM을 다시 그립니다.

객체를 상태로 정의한 후, 객체 내의 프로퍼티에 직접 변화를 주고 해당 객체를 setState로 갱신시켰을 경우 DOM은 다시 그려지지 않습니다. 그 이유는 리액트에서 상태값을 비교할 때 `얕은 비교`를 사용하기 때문입니다. 프로퍼티가 변한 객체는 새로 만들어진 주소값을 가지지 않기 때문에 리액트는 두 객체를 동일한 객체로 인지하고 DOM을 업데이트하지 않습니다.
