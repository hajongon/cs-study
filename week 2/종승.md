---
layout: post
title: cs 스터디 week 2 정리 및 개념 보충
date: 2023-06-30 04:00:00 +0900
category: Interview
published: true
---

<br>

# 1. `Promise`의 기능과 필요한 이유

## 답변

`Promise`를 이용해 우리는 비동기로 작동하는 코드를 제어할 수 있습니다. 그리고 `Promise`는 콜백 함수를 써서 발생하는 callback hell을 방지하는 역할도 수행합니다.

비동기 작업을 순차적으로 진행해야 할 경우, `Promise Chaining`을 사용할 수 있습니다. Promise Chaining이 가능한 이유는 `.then`, `.catch`, `.finally`의 메서드들은 모두 `Promise` 객체를 리턴하기 때문입니다.

<br>

## 꼬리 질문 대비 

### `Promise.all()`

`Promise.all()`은 여러 개의 비동기 작업을 동시에 처리하고 싶을 때 사용합니다. 인자로는 배열을 받고, 해당 배열에 있는 모든 `Promise`에서 `executor` 내에 작성했던 코드들이 정상적으로 처리되면 결과를 배열에 저장해 새로운 `Promise`를 반환합니다.

`Promise.all()`은 인자로 받는 배열에 있는 `Promise` 중 하나라도 에러가 발생하게 되면 나머지 `Promise`의 state와 상관없이 즉시 종료됩니다.

### Async/Await

Async/Await를 통해 `Promise` 코드를 간결하게 작성할 수 있습니다. 함수 앞에 `async` 키워드를 사용하고 그 함수 내에서 `await` 키워드를 사용하면 됩니다. 이렇게 작성한 코드에서는 `await` 키워드가 작성딘 코드가 실행되고 나서 다음 순서의 코드가 동작하게 되어 코드의 비동기적 흐름을 제어할 수 있습니다.

### 자바스크립트 엔진에서 프로미스가 동작하는 방식?

<br>

# 2. 순수함수란?

## 답변

순수 함수는 수학에서의 '함수'를 프로그래밍의 세계로 가져온 모델입니다. 프로그래밍의 세계에는 무언가를 저장, 변경, 호출할 수 있는 '상태'라고 부르는 개념이 존재하지만 수학에는 그런 개념이 없습니다. 

그렇기 때문에 모든 함수는 무언가에 절대 영향을 받지 않고 독립적으로 존재합니다. 이런 수학의 함수를 프로그래밍으로 구현한 모델이 순수함수이므로, 이는 함수 외부의 상태에 영향을 받지 않아야 합니다. 상태라는 개념 자체가 없으니 상태를 변경한다는 개념도 당연히 없고, 이것을 불변성이라고 부릅니다.

하지만 프로그래밍에서 상태를 변경하지 않는다는 것은 굉장히 어려운 일입니다. 그래서 "변수에 값을 재할당하지 않는다"와 같은 몇 가지 규칙들을 정해놓고 프로그래밍을 하면서 불변성을 유지해야 합니다.

## 꼬리질문 대비

### 불변성을 유지한다는 것?

사실 불변성이 이야기하는 '상태의 변경'이라는 것은 단순히 변수의 재할당만을 이야기하는 것은 아닙니다. 정확히 말하면 메모리에 저장된 값을 변경하는 모든 행위를 말하는 것입니다. 불변성을 유지한다는 것의 포인트는 '메모리에 이미 담겨 있는 값을 변경하지 않는다' 라고 할 수 있습니다.

### 불변성을 지킴으로써 얻는 장점?

무분별한 상태의 변경을 막을 수 있다는 것과, 상태의 변경을 추적하기 쉽다는 것. 이렇게 두가지가 불변성을 지켰을 때의 장점입니다.

우선 불변성을 지킨다면 무분별한 상태의 변경을 막을 수 있습니다.

상태라는 건 프로그램의 현재 상황을 보여주는 역할을 하지만, 여기저기서 이 상태를 참조하거나 변경하는 경우에 개발한 사람조차 현재 로직이 어떻게 돌아가는지 파악하기 힘들 수 있습니다.

그래서 개발자들은 상태를 변경하는 행위에 특정한 규칙을 정해서 무분별한 상태 변화를 최대한 피하고, 이런 변화를 추적할 수 있는 상황을 선호할 수 밖에 없습니다.

또, 불변성을 지킨다면 상태의 변경을 추적하기 쉽습니다.

함수 내에서 객체의 프로퍼티를 직접 수정하는 것이 아니라, 새로운 객체를 만들어서 그 객체의 프로퍼티를 변경해준다면 인과관계가 명확해져서 의도하지 않은 객체의 상태 변화를 방어할 수 있고, 또 상태 변화를 추적할 수도 있게 됩니다.

이런 원리는 리액트가 `state`의 변화를 감지하는 데에도 사용되고 있습니다. 리액트는 `Object.is` 라는 메서드를 사용해서 기존의 객체와 `setState`에 넣은 객체가 같다고 판단하면 컴포넌트를 렌더하지 않습니다.

<br>

# 3. React의 state와 props란?

## 답변

`Props`(Properties)는 부모 컴포넌트에서 자식 컴포넌트로 전달되는 데이터를 말합니다. 이는 한 컴포넌트의 속성과 같습니다. 

`State`는 한 컴포넌트 안에서 가변적인 데이터를 다룰 때 사용되며, 이를 통해 컴포넌트 안에서 데이터를 변경할 수 있습니다. 즉 State는 한 컴포넌트의 상태를 나타냅니다.


## 꼬리 질문 대비

### 전역 상태 관리의 필요성

일반적으로 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때, Props를 사용합니다. 하지만 어플리케이션 구조를 만들다보면 props-drilling 현상이 발생하기도 합니다. props-drilling이란, props를 직접 사용하지는 않고 넘겨주는 역할만 하는 여러 컴포넌트들을 거치면서 데이터를 전달하게 되는 과정을 의미합니다. props 전달이 3~4개 정도의 컴포넌트를 거치는 것은 크게 문제가 되지 않습니다. 하지만 10개, 20개 이런 식으로 거쳐야 하는 컴포넌트의 개수가 늘어나게 되면 코드를 읽을 때 해당 props를 추적하기가 힘들어집니다.

이럴 때, 전역으로 상태를 관리할 수 있는 라이브러리를 사용하면 굉장히 편리합니다. 전역 상태 관리 라이브러리로는 `redux`, `recoil`, `Mobx`, `jotai` 등이 있습니다.

상태를 전역으로 관리하면 위에서 언급한 props-drilling 현상을 피할 수 있고 관리 중인 상태의 추적이 쉬워집니다.

<br>

# 4. React 컴포넌트의 key 속성?

## 답변

리액트에서는 자식 요소들을 반복적으로 렌더링하는 상황에서 명시적으로 `key` 속성을 사용합니다. 이를 통해 각 요소의 위치를 파악하고, 새로운 요소가 추가되거나 기존 요소가 삭제될 때 모든 요소를 리렌더링하는 것이 아닌 변경된 부분만을 리렌더링할 수 있게 됩니다.

`key`에는 인덱스 값처럼 요소의 순서에 따라 변경되거나 중복될 수 있는 값이 아닌, `id` 값과 같이 별도의 고유한 문자열을 부여해줘야 합니다.

<br>

# 5. useEffect의 dependency array?

## 답변

`useEffect`는 기본적으로 rendering이 완료된 후에 실행됩니다. `useEffect`의 첫번째 인자는 callback 함수고, 두번째 인자는 dependency array입니다. dependency array를 인자로 넘겨주지 않으면, 렌더링이 일어날 때마다 매번 callback 함수가 실행됩니다.

dependency array를 빈 배열로 넘겨줄 경우, `useEffect`는 렌더링이 완료된 후 한 번만 실행됩니다.

dependency array에 특정 state를 추가하면, `useEffect`의 callback 함수는 렌더링이 된 후에 한 번 실행되고 그 이후에는 해당 `state`가 변경될 때만 실행됩니다.

## 꼬리 질문 대비

### useEffect 내에서 새로운 함수를 정의해 사용하는 것과 컴포넌트에서 함수를 정의해 사용하는 것에는 어떤 차이점이 있는가?

`useEffect` 내에서 정의된 함수는 매번 새로운 함수 인스턴스가 생성되기 때문에 메모리 사용량이 더 많아질 수 있습니다. 특히, `useEffect`가 자주 호출되는 경우 함수 인스턴스가 계속해서 생성되어 메모리 사용량이 늘어날 수 있습니다. 반면에 컴포넌트 내에서 정의된 함수는 컴포넌트의 생명주기 동안 동일한 인스턴스를 유지하기 때문에 메모리 사용량이 더 적습니다.

<br>

# 6. CSR과 SSR의 차이점?

## 답변

작동 시간과 SEO. 이 두 가지에 대한, CSR과 SSR의 차이에 대해 말씀드리겠습니다.

클라이언트에서 렌더링을 할 경우, 사용자와의 상호작용이 빠르게 수행됩니다. 하지만 그 빠른 수행을 위해 초기 화면 띄우는 데까지의 시간은 상대적으로 깁니다. 서버에서 렌더링을 하면 초기 화면을 띄우는 데까지의 시간이 짧고 보안성이 높지만, 매 요청마다 서버의 자원을 많이 사용하기 때문에 클라이언트에서의 작업이 느리게 수행될 수 있습니다.

CSR 방식에서는 클라이언트가 JavaScript 코드를 실행하여 페이지를 렌더링합니다. 서치 엔진은 JavaScript 코드를 실행할 수 없기 때문에 페이지 컨텐츠가 제대로 검색되지 않을 수 있습니다.

SSR 방식에서는 서버가 페이지를 렌더링해서 정적 페이지를 생성한 뒤에 클라이언트에 제공합니다. 이 경우 서치 엔진이 페이지의 컨텐츠를 제대로 파악할 수 있어 SEO에 유리합니다.

하지만 CSR도 요즘에는 서칭 엔진 최적화에 관련된 특정 기술이나 방법을 적용해 유의미한 결과를 만들어내고 있습니다. 대표적인 것으로는 클라이언트 렌더링된 페이지에 태그를 삽입하는 것, 스크립트를 이용한 데이터 구조 개선 등이 있습니다. 그렇다 해도 SSR에 비해 보안성이나 안정성 면에서는 약간 떨어지는 것이 사실입니다.

## 꼬리 질문 대비

### SSR이 최근에 핫한 이유?

<br>

# 7. GET 메서드와 POST 메서드의 차이?

## 답변

GET 메서드와 POST 메서드의 차이에 대해 크게 세가지로 답변드릴 수 있습니다.

첫째, 사용하는 목적입니다.

GET 메서드는 리소스의 조회를 위한 요청이고, POST 메서드는 리소스의 생성 또는 업데이트를 위한 요청입니다.

둘째, 데이터 전송입니다.

GET 메서드의 데이터는 URL의 쿼리 매개 변수를 통해 전송됩니다. 따라서 데이터는 URL에 노출되며 길이에 제한이 있습니다.
Post 메서드의 데이터는 요청 바디에 포함되어 전송됩니다. 따라서 데이터는 URL에 노출되지 않으며, 길이 제한이 없습니다.

마지막으로, 캐싱 여부입니다.

GET 요청에 대한 응답은 캐싱될 수 있습니다. 동일한 GET 요청이 여러 번 발생하면 이전에 받은 응답이 캐시에서 반환될 수 있습니다.
하지만 POST 요청에 대한 응답은 기본적으로 캐싱되지 않습니다. POST 요청은 서버의 상태를 변경하므로 응답이 캐시되어 재사용되는 것은 일반적으로 의도되지 않는 경우입니다.

## 꼬리 질문 대비

### GET 요청에 대한 응답이 캐싱되는 과정

클라이언트가 GET 요청을 서버에 보내면, 서버는 요청을 처리하고 해당 리소스에 대한 응답을 반환합니다. 클라이언트는 응답을 받고, 응답 헤더에 있는 캐싱 관련 정보를 확인합니다. 응답 헤더에 캐싱 관련 지시자가 포함된 경우 클라이언트는 응답을 캐시에 저장합니다. 이후 동일한 GET 요청이 발생하면 클라이언트는 캐시에 저장된 응답을 사용합니다.

<br>

# 8. HTTP 메시지 구조?

## 답변

요청과 응답으로 나눠 답변드리겠습니다.

HTTP 요청은 크게 시작줄, 헤더, 바디로 나누어집니다.
시작줄에는 HTTP 메서드, 요청 타겟, HTTP 버전이 포함되고, 헤더는 Request 헤더, General 헤더, Entity 헤더로 구성됩니다. 바디는 해당 요소를 필요로 하는 요청에 실리게 됩니다. 바디를 필요로 하는 요청에는 POST, PUT, PATCH가 있습니다.

HTTP 응답은 크게 상태줄, 헤더, 본문으로 나누어집니다.
상태줄에는 프로토콜 버전, 상태 코드, 상태 텍스트가 포함되고, 헤더는 Response 헤더, General 헤더, Entity 헤더로 구성됩니다. 응답 바디는 필요에 따라 서버에서 클라이언트 측으로 전송할 수 있습니다.

## 꼬리 질문 대비

<br>

# 9. Same-Origin Policy와 CORS?

## 답변

SOP(Same-Origin Policy)는 웹 보안에 관한 개념입니다.

SOP란, 한 도메인에서 불러온 스크립트가 다른 도메인의 리소스에 접근하지 못하도록 제한하는 것입니다. SOP는 웹 취약점을 차단하고 보안을 강화하는 데 도움이 되며, 개인 정보 유출, 개인 정보 침해, 크로스 사이트 스크립팅 등의 공격에 대한 보호를 제공합니다.

CORS(Cross-Origin Resource Sharing)은 웹 브라우저에서 다른 출처의 웹 자원에 접근하는 것을 허용하는 기술입니다. 웹 브라우저는 SOP에 의해 다른 출처의 웹 자원에는 접근할 수 없지만, CORS는 이러한 제약을 풀어줍니다.

서버에서 CORS를 허용하도록 설정하면, 웹 브라우저는 서버에서 제공하는 HTTP 헤더의 정보를 통해서 다른 출처에서 온 요청이 허용된 것인지 판단할 수 있습니다. 요청이 허용된 경우에 한해서, 웹 브라우저는 다른 출처의 웹 자원에 접근할 수 있게 됩니다.

처음에 서버를 작성할 때, 웹 어플리케이션에서의 CORS 정책을 설정할 수 있습니다. 서버에서 CORS 정책을 설정하는 것은, 어떤 도메인이 서버에 요청을 보낼 수 있는지 제어하는 것입니다.

예를 들어 서버에서 Access-Control-Allow-Origin 헤더를 설정하여 `http://example.com` 도메인에서의 요청만 허용할 수 있도록 할 수 있습니다. 이 경우, 다른 도메인에서의 요청은 허용되지 않습니다. 웹 서버는 다른 도메인에서의 접근을 허용하지 않는 것이 기본입니다. 그러나 특정 경우에서는 접근을 허용하는 것이 필요합니다.예를 들어 공공 API를 제공하는 서버나, 구글 맵 같은 리소스 등이 있습니다.

## 꼬리 질문 대비

### CORS 이슈를 직접 겪어보았는가?

네, 저는 웹 어플리케이션 제작 프로젝트를 수행하던 중 CORS 이슈로 인해 굉장히 애를 먹었던 경험이 있습니다. 백엔드 팀원들이 ngrok 서버를 열어주면 해당 서버를 이용해 테스트를 진행했습니다. ngrok 서버를 이용할 때는 프론트 측에서 프록시로 요청 도메인을 우회하는 방식을 사용해 CORS 에러를 방지했습니다. 백 서버와 클라이언트 서버가 모두 배포되고, 최종 테스트를 진행하려 하는데 CORS 이슈가 발생했습니다.

처음에는 프론트 서버를 메인도메인 `would-you-walk.com`으로 만들고, 프론트 하위도메인로 백엔드 서버를 만들어서 `was.would-you-walk.com` cors 문제를 해결하려고 했습니다. 그런데 Vercel에서 제공하는 게 메인 도메인이 아니라 하위도메인으로 `www.would-you-walk.com`을 제공해서 이렇게 된 경우에는 `was.www.would-you-walk.com` 이렇게 백엔드 서버 도메인을 설정해야 했는데 백엔드 측에서 `was.걸어볼래.com`으로 설정을 했습니다. 그래서 크로스 도메인 문제가 발생했구요.

결국 Spring Security 설정에 Cors 관련 설정하는 부분이 있었는데 해당 설정을 통해서 해결했습니다.

### proxy 동작 원리

프록시는 브라우저와 백엔드 서버 사이에서 일종의 중개 역할을 하는 서버입니다.

브라우저에서 API 요청을 할 시, API 서버에 직접 요청을 하는 것이 아니라 지금 리액트가 구동되는 dev-server 주소로 요청합니다.

dev-server에서 요청을 받으면 그 요청을 API 서버에 전달합니다.
dev-server는 API 서버에서 받은 응답을 다시 브라우저에 전달합니다.

