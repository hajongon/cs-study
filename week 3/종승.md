---
layout: post
title: cs 스터디 week 3 정리 및 개념 보충
date: 2023-07-10 04:00:00 +0900
category: Interview
published: true
---

# 1. 재귀를 활용하기 좋은 상황은 언제인가요?

## 답변

크게 세 가지로 답변드릴 수 있습니다.<br>

첫째, 주어진 문제를 비슷한 구조의 더 작은 문제로 나눌 수 있는 경우<br>
둘째, 반복문으로 작성된 코드를 대체하고 싶은 경우<br>
셋째, 중첩된 반복문이 많거나 반복문의 중첩 횟수를 예측하기 어려운 경우<br>

가 그것입니다.

## 꼬리질문 대비

<br>

# 2. UI, UX의 개념과 두 관계에 대해서 설명해주세요.

## 답변

UI(User Interface)는 사람들이 컴퓨터와 상호 작용하는 시스템입니다.<br>
UX(User Experience)는 사용자가 어떤 시스템, 제품, 서비스를 직/간접적으로 이용하면서 느끼고 생각하는 총체적 경험을 의미합니다.<br>
UX는 UI를 포함합니다. 좋은 UX가 항상 좋은 UI를 보장하거나, 좋은 UI가 항상 좋은 UX를 보장하지는 않습니다.

## 꼬리질문 대비

<br>

# 3. Styled Components를 사용해보면서 느낀 장점을 이야기해주세요.

## 답변

CSS in JS

Styled Components 라이브러리를 사용할 경우 우리는 별도의 css 파일을 만들지 않아도 됩니다.<br>
하나의 파일 안에서 디자인과 로직을 분리해 작성할 수 있다는 장점이 있습니다.<br>
그리고 Styled Components에 props를 전송해서 같은 컴포넌트에 각기 다른 비주얼 프로퍼티를 줄 수도 있습니다.<br>

## 꼬리질문 대비

### 단점은 없나요?

하나의 파일 안에서 로직과 디자인을 한 눈에 볼 수 있다는 장점이 곧 단점이 되기도 합니다.<br>
Styled Components의 양이 늘어나면 코드의 절대적인 양이 늘어나고, 어디에 어떤 컴포넌트의 디자인이 존재하는지 찾기가 어려워집니다. 이를 해결하고자 파일을 분리하게 되면, 기존에 css 파일을 쓰던 것과 큰 차이가 없게 됩니다.<br>
다른 단점으로는 러닝 커브, CSS-in-CSS에 비해 느린 속도 등을 들 수 있습니다.

### Tagged Template Literal

템플릿 리터럴의 발전된 형태입니다. 함수 형태로 사용할 수 있습니다.<br>
이 문법을 이용하면 문자열에서 변수들과 정적 문자열을 구분할 수 있습니다.<br>

```javascript
const userName = 'Jongseung';
const age = 31;

function transform(staticData, ...dynamicData) {
  console.log(staticData); // ["Hi, ", " and I am ", "."]
  console.log(dynamicData); // ["Jongseung", 31]
}

transform`Hi, ${userName} and I am ${age}.`;
```

첫 번째 파라미터에는 정적 데이터가 저장되어 있고, 나머지 파라미터에는 동적 데이터가 저장되어 있습니다.
age 값은 String이 아닌 Number 형태로 타입이 유지됩니다. 만약 `tagged template literal`이 아닌 function으로 호출했다면, 전달되는 파라미터는 단순 하나의 문자열이 됩니다.

`styled-components`에서는 이런 문법을 사용해서 컴포넌트의 props를 읽어오기도 합니다.

```javascript
const Circle = styled.div`
  width: 5rem;
  height: 5rem;
  background: ${props => props.color || 'black'};
  border-radius: 50%;
`;

function App() {
  return <Circle color="blue" />;
}
```

<br>

# 4. useRef가 필요한 상황을 예시를 들어 설명해주세요.

## 답변

첫째, 특정 DOM에 focus를 위치시켜야 하는 경우
둘째, 속성 값을 초기화할 필요가 있는 경우
셋째, 리렌더링을 하지 않으면서 컴포넌트의 속성을 조회 및 수정할 경우

[참고](https://xiubindev.tistory.com/98)

<br>

# 5. 상태관리 라이브러리의 필요성에 대해서 설명해주세요.

## 답변

props drilling 해결

<br>

# 6. Redux의 주요 개념들과 연결 관계를 설명해주세요.

## 답변

### 메인 답변
<br>

`Store`는 상태가 관리되는 오직 하나뿐인 저장소의 역할을 합니다.<br>

`createStore` 메서드를 활용해 Reducer를 연결해서 Store를 생성할 수 있습니다.<br>

`Reducer`는 Dispatch에게서 전달받은 Action 객체의 type 값에 따라서 상태를 변경시키는 함수입니다.<br>
이때, Reducer는 순수함수여야 합니다. 외부 요인으로 인해 기대한 값이 아닌 엉뚱한 값으로 상태가 변경되는 일이 없어야 하기 때문입니다.<br>

`Action`은 말 그대로 어떤 액션을 취할 것인지 정의해 놓은 객체입니다. type은 필수로 지정을 해 주어야 합니다. 해당 Action 객체가 어떤 동작을 하는지 명시해 주는 역할을 하기 때문입니다. 여기에 필요에 따라 payload를 작성해 구체적인 값을 전달합니다.

`Dispatch`는 Reducer로 Action을 전달해 주는 함수입니다. Dispatch의 전달인자로 Action 객체가 전달됩니다.
Action 객체를 전달받은 Dispatch 함수는 Reducer를 호출합니다.

각 개념을 연결시켜주는 훅으로는 두가지가 있습니다.

`useDispatch()`는 Action 객체를 Reducer로 전달해주는 Dispatch 함수를 반환하는 메서드입니다. 
`useSelector()`는 컴포넌트와 state를 연결하여 Redux의 state에 접근할 수 있게 해주는 메서드입니다.


### 리덕스 툴킷을 기준으로 설명 드려도 괜찮을까요?<br>
<br>
Store는 상태가 관리되는 오직 하나뿐인 저장소의 역할을 합니다.<br>

그 저장소의 내부는 여러개의 `slice`로 이루어져 있습니다.<br>

`configureStore`는 여러 개의 `slice`들을 모아주는 역할을 수행합니다.<br>

`createSlice`는 객체를 인자로 받고 그 객체에는 `name`, `initialState`, `reducers`가 필수로 포함됩니다.

- `name`: 이름
- `initialState`: 초기 상태
- `reducers`: 함수(메소드)

`useDispatch()`는 Action 객체를 Reducer로 전달해주는 Dispatch 함수를 반환하는 메서드입니다. 
`useSelector()`는 컴포넌트와 state를 연결하여 Redux의 state에 접근할 수 있게 해주는 메서드입니다.

<br>

## 꼬리질문 대비

### 리덕스 미들웨어에 대해 알고 계신가요?

리덕스 미들웨어 중 redux-logger를 추가하면 액션이 디스패치될 때마다 개발자 도구 콘솔에 로그가 찍히도록 할 수 있습니다.
그리고 커스텀 미들웨어를 작성해 직접 추가해줄 수도 있습니다. 미들웨어를 사용하면 상태의 mutation을 감지하거나 직렬화가 불가능한 값을 사용하는 실수를 방지할 수 있도록 경고 메시지를 띄울 수도 있습니다.

리덕스는 직렬화가 불가능한 값을 액션이나 상태에서 사용하지 않는 것을 권장합니다.
직렬화가 불가능한 값: Promise, Symbol, Map/Set, function, Class, Instance
직렬화가 가능한 값: string, number, null, undefined, array, object literal 방식으로 선언된 plain object

<br>

# 7. IP 프로토콜의 한계에 대해서 설명해주세요.

- 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
- 비신뢰성 
  - 중간에 있는 서버가 데이터를 전달하던 중 패킷이 소실되어도 클라이언트는 파악할 수 없습니다. 
  - 패킷들이 중간에 서로 다른 노드를 통해 전달될 수도 있어서 클라이언트가 의도한 순서대로 서버에 패킷이 도착하는 것을 보장할 수 없습니다.

<br>

# 8. HTTP의 특징

- 클라이언트 서버 구조: 클라이언트가 서버에 요청을 보내면 서버는 클라이언트에게 그에 대한 응답을 보내는 구조
- 무상태 프로토콜 (stateless): HTTP에서 서버가 클라이언트의 상태를 보존하지 않는 무상태 프로토콜입니다.
  - 무상태 프로토콜이라면 클라이언트A가 요청할 때 이미 필요한 데이터를 다 담아서 보내기 때문에 아무 서버나 호출해도 됩니다.
  - 만약 서버1에 장애가 생기더라도 다른 서버에서 응답을 전달하면 되기 때문에 클라이언트는 다시 요청할 필요가 없습니다.
  - 무상태는 응답 서버를 쉽게 바꿀 수 있기 때문에 무한한 서버 증설이 가능합니다.
  - 상태 유지가 필요한 경우? -> 로그인 유지 -> 브라우저 쿠키, 서버 세션, 토큰 등을 사용해서 상태를 유지해야 합니다.

- 비연결성 (connectionless)
  - 실제로 요청을 주고 받을 때만 연결을 유지하고 응답을 주고나면 TCP/IP 연결을 끊습니다. 이를 통해 최소한의 자원으로 서버 유지를 가능하게 합니다.
- 비연결성의 한계
  - TCP/IP 연결을 새로 맺어야 합니다. – 3 way handshake 시간 추가
  - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 JavaScript, CSS, 추가 이미지 등 수많은 자원이 함께 다운로드됩니다.
- 비연결성 극복
  - HTTP 지속 연결 (Persistent Connections): 연결이 이루어지고 난 뒤 각각의 자원들을 요청하고 모든 자원에 대한 응답이 돌아온 후에 연결을 종료합니다.

## 꼬리질문 대비

### IP의 비연결성과 HTTP의 비연결성?

- IP의 비연결성: IP는 네트워크 계층의 프로토콜로서, 데이터를 패킷으로 나누어 서로 다른 네트워크를 통해 목적지까지 전달합니다. IP는 비연결성을 가지며, 이는 각각의 패킷이 독립적으로 라우팅되고 전송된다는 것을 의미합니다. 즉, 같은 메시지의 패킷들이 다른 경로를 통해 전송될 수 있으며, 도착 순서 또한 달라질 수 있습니다. IP는 패킷이 순서대로 도착하거나, 심지어 도착하는 것을 보장하지 않습니다. 이러한 순서와 신뢰성은 보통 상위 레벨의 프로토콜인 TCP (Transmission Control Protocol)에 의해 처리됩니다.

- HTTP의 비연결성: HTTP는 응용 계층의 프로토콜로서, 웹 서버와 클라이언트 사이의 요청-응답 시스템을 구현합니다. HTTP는 기본적으로 비연결성을 가지며, 이는 클라이언트가 요청을 보내고 서버가 응답한 후에 연결이 즉시 끊어진다는 것을 의미합니다. 이로 인해 서버는 동시에 많은 요청을 처리할 수 있습니다. 하지만, 이러한 비연결성은 클라이언트와 서버 사이의 상태를 유지하는 데 문제를 일으킵니다. 이 문제는 일반적으로 쿠키나 세션과 같은 기술을 사용하여 해결됩니다.

요약하면, IP와 HTTP의 비연결성은 비슷한 개념이지만, 각각 패킷 레벨의 라우팅과 응용 계층의 요청-응답 모델에 적용되어 다르게 작동합니다.

### 프로토콜이란?

- 프로토콜은 데이터를 송수신하기 위한 규칙을 말합니다.
- 통신하기 위한 다양한 방법이 존재할 수 있고, 그 방법 하나하나를 전부 프로토콜이라고 합니다.

### OSI 7계층

- 응용 계층: 사용자가 OSI 환경에 접근할 수 있도록 서비스를 제공합니다. 프로토콜을 이용해서 서비스를 사용하는 계층입니다.
- 표현 계층: 응용 계층에서 받은 데이터를 세션 계층에 맞게 변환하거나, 세션 계층에서 받은 데이터를 응용 계층에 맞게 변환합니다.
- 세션 계층: 송수신 측 간의 관련성을 유지시킵니다. 송수신 측 간의 대화 제어를 담당합니다. 동기 제어를 하고, 데이터 교환을 관리합니다.
- 전송 계층: 데이터가 실제 전송되는 구간입니다. (게이트웨이)
- 네트워크 계층: 네트워크 연결을 관리합니다. 경로 설정, 연결, 해제, 패킷 전송 (라우터)
- 데이터 링크 계층: 두 개의 인접한 개방 시스템끼리, 신뢰성 있고 효율적인 정보 전송이 가능하게 합니다. (랜카드, 브릿지, 스위치)
- 물리 계층: 전송에 필요한 두 장치 간 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성을 정의합니다. (증폭기, 허브)


[참조](https://hanamon.kr/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ea%b8%b0%eb%b3%b8-%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c%ec%9d%b4%eb%9e%80-osi-7-%ea%b3%84%ec%b8%b5-%eb%b3%84-%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c/)
